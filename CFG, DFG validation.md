经过 **RAG 存在性校验** 后，可以得到一串候选技能节点序列。  
接下来，需要依次进行 **子图与 CFG 的比对**，并在此基础上构建并校验 **DFG**。

---

## CFG 校验逻辑

1. **主干节点连接**：取出所有不带 `auxiliary_for` 属性的节点，作为任务主链；顺序连接相邻主节点，形成基本的控制流。
    
2. **辅助分支挂载**：若某个节点带有 `auxiliary_for` 属性，说明它是某个主节点的辅助操作（如 `SetPathConstraints` 辅助 `ComputePathToPose`）。程序会找到该主节点对应的实例，并为辅助节点补充一条边，使其正确挂载到目标主节点上。
    
3. **结果**：得到一张表示执行顺序的 **控制流子图 (CFG)**，确保所有节点都能在逻辑上正确衔接。
    

---

##  DFG 校验逻辑

1. **依赖范围限定**：仅在 CFG 已确认存在执行关系的节点对 `(src, dst)` 之间，才检查可能的数据流。
    
2. **端口枚举**：对每条 CFG 边，遍历源节点 `src.outputs` 和目标节点 `dst.inputs`，生成候选数据依赖。
    
3. **端口原型比对**：去掉实例编号部分（如 `#1`, `#2`），仅按端口的原型名进行匹配。
    
4. **Neo4j flowsTo 校验**：确认候选的 `outp_proto → inp_proto` 是否存在于 Neo4j 知识库的 `flowsTo` 关系中。
    
5. **类型一致性检查**：若输出端口类型与输入端口类型兼容，则建立 DFG 边；若不兼容，则记录为类型冲突。
    

---


- **CFG 保证控制流逻辑正确**（节点顺序与挂载关系合法），
    
- **DFG 保证数据依赖正确**（数据流方向和类型一致）。
    

二者结合，形成了 **双图一致性验证** 的完整闭环。